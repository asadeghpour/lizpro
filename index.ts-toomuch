import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { 
  CallToolRequestSchema, 
  ListToolsRequestSchema,
  ErrorCode,
  McpError
} from "@modelcontextprotocol/sdk/types.js";

// --- 1. THE FULL 38-TOOL MAP ---
const CoreResources = {
  BINDINGS: 'bindings',
  COMPONENT_STATUSES: 'componentstatuses',
  CONFIG_MAPS: 'configmaps',
  ENDPOINTS: 'endpoints',
  EVENTS: 'events',
  LIMIT_RANGES: 'limitranges',
  NAMESPACES: 'namespaces',
  NODES: 'nodes',
  PERSISTENT_VOLUME_CLAIMS: 'persistentvolumeclaims',
  PERSISTENT_VOLUMES: 'persistentvolumes',
  PODS: 'pods',
  POD_TEMPLATES: 'podtemplates',
  REPLICATION_CONTROLLERS: 'replicationcontrollers',
  RESOURCE_QUOTAS: 'resourcequotas',
  SECRETS: 'secrets',
  SERVICE_ACCOUNTS: 'serviceaccounts',
  SERVICES: 'services',
} as const;

const SubResources = {
  NAMESPACES_FINALIZE: 'namespaces/finalize',
  NAMESPACES_STATUS: 'namespaces/status',
  NODES_PROXY: 'nodes/proxy',
  NODES_STATUS: 'nodes/status',
  PVC_STATUS: 'persistentvolumeclaims/status',
  PV_STATUS: 'persistentvolumes/status',
  PODS_ATTACH: 'pods/attach',
  PODS_BINDING: 'pods/binding',
  PODS_EPHEMERALCONTAINERS: 'pods/ephemeralcontainers',
  PODS_EVICTION: 'pods/eviction',
  PODS_EXEC: 'pods/exec',
  PODS_LOG: 'pods/log',
  PODS_PORTFORWARD: 'pods/portforward',
  PODS_PROXY: 'pods/proxy',
  PODS_RESIZE: 'pods/resize',
  PODS_STATUS: 'pods/status',
  RC_SCALE: 'replicationcontrollers/scale',
  RC_STATUS: 'replicationcontrollers/status',
  QUOTA_STATUS: 'resourcequotas/status',
  SA_TOKEN: 'serviceaccounts/token',
  SERVICES_PROXY: 'services/proxy',
  SERVICES_STATUS: 'services/status',
} as const;

const AllV1Tools = { ...CoreResources, ...SubResources };

// --- 2. DISPATCHER ---
const K8sToolDispatcher = {
  baseUrl: "https://prime.elemental.org:8443/k8s/clusters/local/api/v1",
  async call(resourcePath: string, args: { name?: string, namespace?: string }) {
    let urlPath = args.namespace 
      ? `/namespaces/${args.namespace}/${resourcePath}/${args.name || ''}`
      : `/${resourcePath}/${args.name || ''}`;
    
    return { action: "CALL", url: `${this.baseUrl}${urlPath}`.replace(/\/$/, "") };
  }
};

// --- 3. SERVER ---
const server = new Server(
  { name: "LizardPro-Integrated", version: "1.0.0" },
  { capabilities: { tools: { listChanged: true } } }
);

// --- 4. HANDLERS ---
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: Object.entries(AllV1Tools).map(([key, path]) => ({
      name: `k8s_${key.toLowerCase()}`,
      description: `Access Kubernetes ${path}`,
      inputSchema: {
        type: "object",
        properties: {
          name: { type: "string" },
          namespace: { type: "string" },
        }
      }
    }))
  };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const toolName = request.params.name.replace("k8s_", "").toUpperCase();
  const resourcePath = (AllV1Tools as any)[toolName];

  if (!resourcePath) {
    throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${request.params.name}`);
  }

  const args = (request.params.arguments || {}) as { name?: string; namespace?: string };
  const result = await K8sToolDispatcher.call(resourcePath, args);

  return {
    content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
  };
});

// --- 5. CONNECT ---
const transport = new StdioServerTransport();
await server.connect(transport);
