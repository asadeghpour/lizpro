import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import axios from "axios";
import https from "https";

// Configuration
const RANCHER_URL = process.env.RANCHER_URL || "";
const RANCHER_TOKEN = process.env.RANCHER_TOKEN || "";

const rancherClient = axios.create({
  baseURL: RANCHER_URL,
  headers: {
    'Authorization': `Bearer ${RANCHER_TOKEN}`,
    'Content-Type': 'application/json'
  },
  httpsAgent: new https.Agent({ rejectUnauthorized: false })
});

const server = new Server(
  { name: "rancher-manager", version: "1.2.0" },
  { capabilities: { tools: {} } }
);

// 1. Tool Definitions
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "list_rke_clusters",
        description: "Lists all clusters. Returns Name and internal clusterId (e.g. c-m-xxxxx). Always use clusterId for health/pods.",
        inputSchema: { type: "object", properties: {} },
      },
      {
        name: "get_node_health",
        description: "Get CPU/Mem summary for nodes. Requires internal clusterId.",
        inputSchema: {
          type: "object",
          properties: {
            clusterId: { type: "string", description: "The internal ID (e.g. c-m-xxxxx) from list_rke_clusters" }
          },
          required: ["clusterId"]
        }
      },
      {
        name: "list_cluster_pods",
        description: "Lists pods. Can be filtered by nodeId to find 'noisy neighbors' on a specific node.",
        inputSchema: {
          type: "object",
          properties: {
            clusterId: { type: "string", description: "The internal cluster ID" },
            nodeId: { type: "string", description: "Optional: Filter pods by a specific Node ID (found in get_node_health)" }
          },
          required: ["clusterId"]
        }
      }
    ],
  };
});

// 2. Tool Logic
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name } = request.params;
  const args = request.params.arguments as any;

  try {
    if (name === "list_rke_clusters") {
      const response = await rancherClient.get("/provisioning.cattle.io.clusters");
      // Map clusterName to clusterId so the AI sees the 'c-m-xxxx' value immediately
      const clusters = response.data.data.map((c: any) => ({
        name: c.metadata.name,
        clusterId: c.status?.clusterName || c.metadata.name,
        status: c.status?.ready === "True" ? "Ready" : "Provisioning"
      }));
      return { content: [{ type: "text", text: JSON.stringify(clusters, null, 2) }] };
    }

    if (name === "get_node_health") {
      // Use the internal ID to query management nodes
      const response = await rancherClient.get(`/v1/management.cattle.io.nodes?clusterId=${args.clusterId}`);
      const nodes = response.data.data.map((n: any) => ({
        id: n.id, // e.g. "c-m-xxxxx:m-yyyyy"
        hostname: n.hostname,
        cpuUsage: n.requested?.cpu || "0",
        memUsage: n.requested?.memory || "0",
        state: n.state
      }));
      return { content: [{ type: "text", text: JSON.stringify(nodes, null, 2) }] };
    }

    if (name === "list_cluster_pods") {
      // Base URL for pods
      let url = `/v3/pods?clusterId=${args.clusterId}`;
      
      // Node-specific filter
      if (args.nodeId) {
        url += `&nodeId=${args.nodeId}`;
      }

      const response = await rancherClient.get(url);
      const pods = response.data.data.map((p: any) => ({
        name: p.name,
        namespace: p.namespaceId,
        nodeId: p.nodeId,
        state: p.state
      }));
      return { content: [{ type: "text", text: JSON.stringify(pods, null, 2) }] };
    }

    throw new Error(`Tool not found: ${name}`);
  } catch (error: any) {
    return {
      isError: true,
      content: [{ type: "text", text: `Rancher Error: ${error.response?.data?.message || error.message}` }],
    };
  }
});

async function runServer() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("Rancher MCP Server running");
}

runServer().catch(console.error);
